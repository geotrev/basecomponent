{"version":3,"file":"rotom.template.min.js","sources":["../src/utilities/create-uuid.js","../src/utilities/is-type.js","../src/utilities/transform-case.js","../src/utilities/sanitize-string.js","../src/scheduler/index.js","../src/enums.js","../src/properties/initialize-property-value.js","../src/properties/upgrade-property.js","../src/renderers/template/utilities/index.js","../src/observers/index.js","../src/rotom.template.js","../src/rotom-factory.js","../src/renderers/template/renderer.js","../src/register.js","../src/properties/validate-type.js","../src/utilities/log.js"],"sourcesContent":["/**\n * Generates a unique 19 digit ID based on Date.now() and MAX_SAFE_INTEGER\n * @returns {string}\n */\nexport const createUUID = () => {\n  const base = Number.MAX_SAFE_INTEGER\n  return (\n    Math.floor(Math.random() * base).toString(36) +\n    Math.abs(Date.now()).toString(36)\n  )\n}\n","/**\n * Returns the stringified data type as given from the object tag.\n * @param {*} value\n * @returns {string}\n */\nexport const getTypeTag = (value) =>\n  Object.prototype.toString.call(value).slice(8, -1).toLowerCase()\n\n/**\n * Checks if the value is an object literal.\n * @param {*} value\n * @returns {boolean}\n */\nexport const isPlainObject = (value) => getTypeTag(value) === \"object\"\n\n/**\n * Checks if the value is an object literal with no enumerable properties.\n * @param {*} value\n * @returns {boolean}\n */\nexport const isEmptyObject = (value) => {\n  if (!isPlainObject(value)) return false\n\n  for (let key in value) {\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Checks if the value is a function.\n * @param {*} value\n * @returns {boolean}\n */\nexport const isFunction = (value) => getTypeTag(value) === \"function\"\n\n/**\n * Checks if the value is a string literal.\n * @param {*} value\n * @returns {boolean}\n */\nexport const isString = (value) => getTypeTag(value) === \"string\"\n\n/**\n * Checks if the value is undefined.\n * @param {*} value\n * @returns {boolean}\n */\nexport const isUndefined = (value) => getTypeTag(value) === \"undefined\"\n","/**\n * Converts a camel- or Pascal-case string to kebab-case.\n * @param {string} value\n * @returns {string}\n */\nexport const toKebabCase = (value) =>\n  value &&\n  value\n    .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)\n    .map((x) => x.toLowerCase())\n    .join(\"-\")\n","/**\n * Sanitize a string value to remove special characters.\n * @param {string} value\n * @returns {string}\n */\nexport const sanitizeString = (value) => {\n  const dump = document.createElement(\"div\")\n  dump.textContent = value\n  return \"\" + dump.innerHTML\n}\n","import { isFunction } from \"../utilities\"\n\n/**\n * This scheduler uses either requestAnimationFrame or setTimeout\n * to schedule a function at approximately the next frame.\n *\n * These need to be async because the function may block other\n * operations before updating.\n */\n\nexport function createScheduler() {\n  // Store these in case for some reason they are reassigned later.\n  const requestAnimationFrame = window.requestAnimationFrame\n  const setTimeout = window.setTimeout\n  const FRAME_DURATION = 1000 / 60\n  let scheduled = null\n\n  /**\n   * Executes a rAF or timeout (depending on which is available)\n   * If a fn is already scheduled, nothing happens.\n   */\n  function schedule(fn) {\n    if (scheduled) return\n\n    if (isFunction(requestAnimationFrame)) {\n      scheduled = requestAnimationFrame(() => {\n        scheduled = null\n        fn()\n      })\n    } else if (isFunction(setTimeout)) {\n      scheduled = setTimeout(() => {\n        scheduled = null\n        fn()\n      }, FRAME_DURATION)\n    }\n  }\n\n  return (fn) => schedule(fn)\n}\n","export const Attributes = {\n  dir: \"dir\",\n}\n\nexport const AttributeValues = {\n  ltr: \"ltr\",\n}\n\nexport const External = {\n  // Properties & methods\n  rotomIdProperty: \"rotomId\",\n  requestRender: \"requestRender\",\n  render: \"render\",\n  staticProperties: \"properties\",\n  staticStyles: \"styles\",\n\n  // Attributes\n  rotomIdAttribute: \"rotom-id\",\n\n  // Lifecycle\n  onConnect: \"onConnect\",\n  onMount: \"onMount\",\n  onUpdate: \"onUpdate\",\n  onPropertyChange: \"onPropertyChange\",\n  onAttributeChange: \"onAttributeChange\",\n  onUnmount: \"onUnmount\",\n}\n\nexport const Internal = {\n  // Primitives\n  rotomId: Symbol(\"#rotomId\"),\n  vDOM: Symbol(\"#vDOM\"),\n  isFirstRender: Symbol(\"#isFirstRender\"),\n\n  // Methods\n  renderer: Symbol(\"#renderer\"),\n  initialize: Symbol(\"#initialize\"),\n  schedule: Symbol(\"#schedule\"),\n  runLifecycle: Symbol(\"#runLifecycle\"),\n  upgrade: Symbol(\"#upgrade\"),\n  upgradeProperties: Symbol(\"#upgradeProperties\"),\n  renderStyles: Symbol(\"#renderStyles\"),\n  renderDOM: Symbol(\"#renderDOM\"),\n  patch: Symbol(\"#patch\"),\n  destroy: Symbol(\"#destroy\"),\n}\n","import { validateType } from \"./validate-type\"\nimport {\n  isFunction,\n  isUndefined,\n  toKebabCase,\n  sanitizeString,\n} from \"../utilities\"\n\nexport const initializePropertyValue = (\n  RotomInstance,\n  propName,\n  configuration,\n  privateName\n) => {\n  const {\n    default: defaultValue,\n    type: propType,\n    reflected = false,\n    safe = false,\n  } = configuration\n\n  // Initializing the property value:\n  //\n  // 1. If the default is a function, call it with the instance itself\n  //    as the only argument\n  // 2. If the prop name happens to be an existing property, set aside\n  //    the property's value to a separate prop and use its value on\n  //    the replacement\n  // 3. Otherwise, just set the value as the default\n\n  let initialValue\n\n  if (isFunction(defaultValue)) {\n    initialValue = defaultValue(RotomInstance)\n  } else if (typeof RotomInstance[propName] !== \"undefined\") {\n    initialValue = RotomInstance[propName]\n\n    // Set aside the initial value to a new property, before it's\n    // deleted by the new accessors.\n    RotomInstance[`__${propName}_initial`] = initialValue\n  } else {\n    initialValue = defaultValue\n  }\n\n  // Validate the property's default value type, if given\n  // Initialize the private property\n\n  if (!isUndefined(initialValue)) {\n    if (BUILD_ENV === \"development\") {\n      validateType(RotomInstance, propName, initialValue, propType)\n    }\n\n    if (safe && typeof initialValue === \"string\") {\n      initialValue = sanitizeString(initialValue)\n    }\n\n    RotomInstance[privateName] = initialValue\n  }\n\n  // If the value is reflected, set its attribute.\n\n  if (reflected) {\n    const initialAttrValue = initialValue ? String(initialValue) : \"\"\n    const attribute = toKebabCase(propName)\n    RotomInstance.setAttribute(attribute, initialAttrValue)\n  }\n}\n","import { Internal, External } from \"../enums\"\nimport { isUndefined, toKebabCase, sanitizeString } from \"../utilities\"\nimport { initializePropertyValue } from \"./initialize-property-value\"\nimport { validateType } from \"./validate-type\"\n\n/**\n * Upgrade a property based on its configuration. If accessors are detected in\n * the extender, skip the upgrade.\n * @param {Object} RotomInstance\n * @param {string} propName\n * @param {{value, default, reflected}} configuration\n */\nexport const upgradeProperty = (\n  RotomInstance,\n  propName,\n  configuration = {}\n) => {\n  // If the constructor class is using its own setter/getter, bail\n  if (\n    Object.getOwnPropertyDescriptor(\n      Object.getPrototypeOf(RotomInstance),\n      propName\n    )\n  ) {\n    return\n  }\n\n  const privateName = Symbol(propName)\n  const { type, reflected = false, safe = false } = configuration\n\n  initializePropertyValue(RotomInstance, propName, configuration, privateName)\n  // Finally, declare its accessors\n\n  Object.defineProperty(RotomInstance, propName, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return RotomInstance[privateName]\n    },\n    set(value) {\n      // Don't set if the value is the same to prevent unnecessary re-renders.\n      if (value === RotomInstance[privateName]) return\n\n      if (BUILD_ENV === \"development\") {\n        validateType(RotomInstance, propName, value, type)\n      }\n\n      const oldValue = RotomInstance[privateName]\n\n      if (!isUndefined(value)) {\n        RotomInstance[privateName] =\n          safe && type === \"string\" && typeof value === \"string\"\n            ? sanitizeString(value)\n            : value\n\n        RotomInstance[Internal.runLifecycle](\n          External.onPropertyChange,\n          propName,\n          oldValue,\n          value\n        )\n\n        if (reflected) {\n          const attribute = toKebabCase(propName)\n          const attrValue = String(value)\n          RotomInstance.setAttribute(attribute, attrValue)\n        }\n      } else {\n        delete RotomInstance[privateName]\n\n        RotomInstance[Internal.runLifecycle](\n          External.onPropertyChange,\n          propName,\n          oldValue,\n          value\n        )\n\n        if (reflected) {\n          const attribute = toKebabCase(propName)\n          RotomInstance.removeAttribute(attribute)\n        }\n      }\n\n      RotomInstance[External.requestRender]()\n    },\n  })\n}\n","/**\n * Returns the stringified data type as given from the object tag.\n * @param {*} value\n * @returns {string}\n */\nconst getTypeTag = (value) =>\n  Object.prototype.toString.call(value).slice(8, -1).toLowerCase()\n\n/**\n * Checks if the value is a function.\n * @param {*} value\n * @returns {boolean}\n */\nexport const isFunction = (value) => getTypeTag(value) === \"function\"\n\n/**\n * Checks if the value is a string literal.\n * @param {*} value\n * @returns {boolean}\n */\nexport const isString = (value) => getTypeTag(value) === \"string\"\n","export function createDirectionObserver() {\n  if (window.__ROTOM_ELEMENT__DIR_OBSERVER__) return\n  window.__ROTOM_ELEMENT__DIR_OBSERVER__ = true\n\n  /**\n   * Search for other rotom elements, denoted by the\n   * presence of `rotom-id` on the element, and update\n   * its document direction.\n   * @param {HTMLElement|ShadowRoot} context\n   */\n  const updateDirection = (context = document) => {\n    const nodes = Array.apply(null, context.querySelectorAll(\"[rotom-id]\"))\n    if (!nodes.length) return\n\n    nodes.forEach((node) => {\n      node.setAttribute(\"dir\", String(document.dir || \"ltr\"))\n\n      if (node.shadowRoot) {\n        updateDirection(node.shadowRoot)\n      }\n    })\n  }\n\n  const mutationObserver = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.attributeName === \"dir\") {\n        updateDirection()\n      }\n    })\n  })\n\n  mutationObserver.observe(document.documentElement, { attributes: true })\n}\n","import { rotomFactory } from \"./rotom-factory\"\nimport { renderer } from \"./renderers/template\"\nimport { createDirectionObserver } from \"./observers\"\n\ncreateDirectionObserver()\n\nexport const Rotom = rotomFactory(renderer)\nexport { register } from \"./register\"\nexport { validateType } from \"./properties\"\n","import { createScheduler } from \"./scheduler\"\nimport { upgradeProperty } from \"./properties\"\nimport { Internal, External, Attributes, AttributeValues } from \"./enums\"\nimport {\n  isEmptyObject,\n  isString,\n  isFunction,\n  toKebabCase,\n  createUUID,\n} from \"./utilities\"\n\nconst SHADOW_ROOT_MODE = \"open\"\n\nexport function rotomFactory(renderer) {\n  /**\n   * @module Rotom\n   * @extends HTMLElement\n   */\n  return class Rotom extends HTMLElement {\n    constructor() {\n      super()\n\n      // Internal methods, properties, and data\n      this[Internal.schedule] = createScheduler()\n      this[Internal.renderer] = renderer({ Internal, External })\n\n      this.attachShadow({ mode: SHADOW_ROOT_MODE })\n\n      this[Internal.patch] = this[Internal.patch].bind(this)\n      this[Internal.isFirstRender] = true\n      this[Internal.vDOM] = null\n      this[Internal.rotomId] = createUUID()\n    }\n\n    // Retrieve defined properties from the constructor.\n    static get observedAttributes() {\n      const properties = this[External.staticProperties]\n\n      if (isEmptyObject(properties)) return []\n\n      let attributes = []\n      for (let propName in properties) {\n        if (!properties[propName].reflected) continue\n        attributes.push(toKebabCase(propName))\n      }\n      return attributes\n    }\n\n    // Keep adoptedCallback around in case it becomes useful later.\n    // Consumers will need to call super() to remain compatible,\n    // in the mean time.\n    adoptedCallback() {}\n\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (oldValue !== newValue) {\n        this[Internal.runLifecycle](\n          External.onAttributeChange,\n          name,\n          oldValue,\n          newValue\n        )\n      }\n    }\n\n    connectedCallback() {\n      // It's possible for elements to queue this callback\n      // and then disconnect before resolving. This ensures\n      // the element is actually connected before proceeding.\n      if (!this.isConnected) return\n\n      this[Internal.upgrade]()\n      this[Internal.runLifecycle](External.onConnect)\n      this[Internal.renderStyles]()\n      this[External.requestRender]()\n    }\n\n    disconnectedCallback() {\n      this[Internal.runLifecycle](External.onUnmount)\n      this[Internal.destroy]()\n    }\n\n    // Public\n\n    /**\n     * Returns the Internal element id.\n     * @returns {string}\n     */\n    get [External.rotomIdProperty]() {\n      return this[Internal.rotomId]\n    }\n\n    /**\n     * Requests a new render.\n     */\n    [External.requestRender]() {\n      this[Internal.schedule](this[Internal.patch])\n    }\n\n    // Private\n\n    /**\n     * If the method is defined by the constructor, run it.\n     * @param {string} methodName - name of the possible method\n     * @param {arguments} args - args to pass along to the method, if any\n     */\n    [Internal.runLifecycle](methodName, ...args) {\n      if (isFunction(this[methodName])) {\n        this[methodName](...args)\n      }\n    }\n\n    [Internal.upgrade]() {\n      // Set element id prop as an attribute\n      this.setAttribute(\n        External.rotomIdAttribute,\n        this[External.rotomIdProperty]\n      )\n\n      // Set document direction for reflow support in shadow roots\n      this.setAttribute(\n        Attributes.dir,\n        String(document.dir || AttributeValues.ltr)\n      )\n\n      // Upgrade stateful properties\n      this[Internal.upgradeProperties]()\n    }\n\n    /**\n     * Upgrade properties detected in the constructor.\n     */\n    [Internal.upgradeProperties]() {\n      const properties = this.constructor[External.staticProperties]\n\n      if (isEmptyObject(properties)) return\n\n      for (let propName in properties) {\n        upgradeProperty(this, propName, properties[propName])\n      }\n    }\n\n    /**\n     * Called during disconnectedCallback. Clean up the vDOM\n     * and remove remaining nodes in the shadowRoot.\n     */\n    [Internal.destroy]() {\n      this[Internal.renderer].destroy(this)\n    }\n\n    /**\n     * Called during renderDOM. Runs reconciliation and updates\n     * the DOM with the new render state\n     */\n    [Internal.patch]() {\n      this[Internal.renderer].patch(this)\n    }\n\n    /**\n     * Creates the style tag and appends styles as detected in the constructor.\n     */\n    [Internal.renderStyles]() {\n      const styles = this.constructor[External.staticStyles]\n\n      if (!isString(styles)) return\n\n      const styleTag = document.createElement(\"style\")\n      styleTag.type = \"text/css\"\n      styleTag.textContent = styles\n      this.shadowRoot.appendChild(styleTag)\n    }\n  }\n}\n","import { patch, render, create } from \"omdomdom\"\nimport { isString, isFunction } from \"./utilities\"\n\nexport function renderer({ Internal, External }) {\n  function getRenderState(element) {\n    let domString\n\n    if (isFunction(element[External.render])) {\n      domString = element[External.render]()\n    } else {\n      throw new Error(\n        `[Rotom]: You must include a render method in element: '${element.constructor.name}'`\n      )\n    }\n\n    if (!isString(domString)) {\n      throw new Error(\n        `[Rotom]: You attempted to render a non-string template in element: '${element.constructor.name}'.`\n      )\n    }\n\n    return domString\n  }\n\n  function setInitialRenderState(element) {\n    element[Internal.vDOM] = create(getRenderState(element))\n    render(element[Internal.vDOM], element.shadowRoot)\n    element[Internal.runLifecycle](External.onMount)\n  }\n\n  function setNextRenderState(element) {\n    let nextVDOM = create(getRenderState(element))\n    patch(nextVDOM, element[Internal.vDOM])\n    element[Internal.runLifecycle](External.onUpdate)\n    nextVDOM = null\n  }\n\n  return {\n    patch(element) {\n      if (!window || !window.document) return\n\n      if (element[Internal.isFirstRender]) {\n        element[Internal.isFirstRender] = false\n        setInitialRenderState(element)\n      } else {\n        setNextRenderState(element)\n      }\n    },\n    destroy(element) {\n      if (!window || !window.document) return\n\n      const emptyVNode = {\n        type: \"comment\",\n        attributes: {},\n        children: null,\n        content: \"\",\n        node: document.createComment(\"\"),\n      }\n\n      element[Internal.isFirstRender] = true\n      patch(emptyVNode, element[Internal.vDOM])\n      element[Internal.vDOM] = null\n\n      const children = element.shadowRoot.childNodes\n      if (children.length) {\n        Array.prototype.forEach.call(children, (child) =>\n          element.shadowRoot.removeChild(child)\n        )\n      }\n    },\n  }\n}\n","/**\n * Adds custom element to the global registry.\n * @param {string} tag\n * @param {module} RotomInstance\n */\nexport const register = (tag, RotomInstance) => {\n  if (!customElements.get(tag)) {\n    customElements.define(tag, RotomInstance)\n  }\n}\n","import { log, getTypeTag } from \"../utilities\"\n\nexport function validateType(Instance, propName, value, type) {\n  if (typeof type === \"undefined\") return\n\n  const evaluatedType = getTypeTag(value)\n\n  if (type === undefined || evaluatedType === type) return\n\n  log(\n    `Property '${propName}' is invalid type of '${evaluatedType}'. Expected '${type}'. Check ${Instance.constructor.name}.`\n  )\n}\n","/**\n * Logs a message of the specified type\n * @param {string} msg\n * @param {string} type\n */\nexport function log(msg, type = \"warn\") {\n  // eslint-disable-next-line no-console\n  console[type](`[Rotom]: ${msg}`)\n}\n"],"names":["getTypeTag","value","Object","prototype","toString","call","slice","toLowerCase","isEmptyObject","isPlainObject","key","hasOwnProperty","isFunction","isUndefined","toKebabCase","match","map","x","join","sanitizeString","dump","document","createElement","textContent","innerHTML","createScheduler","requestAnimationFrame","window","setTimeout","scheduled","fn","schedule","Attributes","AttributeValues","External","rotomIdProperty","requestRender","render","staticProperties","staticStyles","rotomIdAttribute","onConnect","onMount","onUpdate","onPropertyChange","onAttributeChange","onUnmount","Internal","rotomId","Symbol","vDOM","isFirstRender","renderer","initialize","runLifecycle","upgrade","upgradeProperties","renderStyles","renderDOM","patch","destroy","initializePropertyValue","RotomInstance","propName","configuration","privateName","default","defaultValue","type","propType","reflected","safe","initialValue","initialAttrValue","String","attribute","setAttribute","upgradeProperty","getOwnPropertyDescriptor","getPrototypeOf","defineProperty","configurable","enumerable","get","set","oldValue","removeAttribute","attrValue","__ROTOM_ELEMENT__DIR_OBSERVER__","updateDirection","context","nodes","Array","apply","querySelectorAll","length","forEach","node","dir","shadowRoot","MutationObserver","mutations","mutation","attributeName","observe","documentElement","attributes","createDirectionObserver","Rotom","HTMLElement","constructor","attachShadow","mode","this","bind","base","Number","MAX_SAFE_INTEGER","Math","floor","random","abs","Date","now","createUUID","properties","push","adoptedCallback","attributeChangedCallback","name","newValue","connectedCallback","isConnected","disconnectedCallback","methodName","args","styles","styleTag","appendChild","rotomFactory","getRenderState","element","domString","Error","isString","create","setInitialRenderState","nextVDOM","setNextRenderState","emptyVNode","children","content","createComment","childNodes","child","removeChild","tag","customElements","define","Instance","evaluatedType","undefined","msg","console","log"],"mappings":"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"}